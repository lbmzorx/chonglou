<?php
/**
 * Created by PhpStorm.
 * User: aa
 * Date: 2018/3/8
 * Time: 14:02
 */

namespace app\models\redis;


use yii\base\Component;

/**
 * 操作Redishash结构数据，对一些方法进行封装
 * Class RedisHash
 * @package app\models\grab
 */
class RedisOperation extends Component
{
    public $redis_config_name='redis';

    /**
     * @var \yii\redis\Connection
     */
    public $redis;

    private $_errors;     //保存错误记录

    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        $this->getRedis();
    }

    /**
     * 获取redis连接
     * @return null|object|\yii\redis\Connection
     */
    public function getRedis(){
        if($this->redis == null){
            $this->redis=\yii::$app->get($this->redis_config_name);
        }
        return $this->redis;
    }

    /**
     * redis 中键是否存在
     * @param $key
     * @return mixed
     */
    public function existKey($key){
        return $this->redis->exists($key);
    }

    /**
     * 使用hgetall方法获取hash中的值
     * @param $key
     * @return array|bool
     */
    public function getHash($key){
        $redis=\yii::$app->redis_db;
        $data=$redis->hgetall($key);
        if(is_array($data)){
            $count=count($data);
            $result=[];
            for($i=0;$i<($count/2);$i++){
                $result[$data[2*$i]]=$data[(2*$i+1)];
            }
            return $result;
        }
        return false;
    }

    /**
     * 扫描所有数据,通过递归的方式，返回的数据可能有重复，但是不会阻塞业务
     * @param $cursor
     * @param string $match     "MATCH"
     * @param $pattern
     * @param string $COUNT     "COUNT"
     * @param $count
     */
    public function scanAll($cursor,$match=null,$pattern=null,$COUNT=null,$count=null){
        return $this->redis->scan($cursor,$match,$pattern,$COUNT,$count);
    }

    /**
     * 序列化扫描到的数据
     * @param $key
     * @param $cursor
     * @param null $match
     * @param null $pattern
     * @param null $COUNT
     * @param null $count
     */
    public function scanHash($key,$cursor,$match=null,$pattern=null,$COUNT=null,$count=null){
        $result= $this->redis->hscan($key,$cursor,$match,$pattern,$COUNT,$count);
        if(isset($result[1])){
            $data=[];
            $count=count($result[1]);
            for($i=0;$i<($count/2);$i++){
                $data[$result[1][2*$i]]=$result[1][(2*$i+1)];
            }
            $result[1]=$data;
        }
    }

    /**
     * 设置 hash 值
     * @param $key
     * @param $field
     * @param $value
     * @return mixed
     */
    public function setHashField($key,$field,$value){
        return $this->redis->hset($key,$field,$value);
    }

    /**
     * 保存数组到 redis
     * @param $key
     * @param $values
     */
    public function setHash($key,$values){
        $field=[];
        foreach ($values as $k => $v){
            $field[]=$k;
            $field[]=$v;
        }
        array_unshift($field,$key);
        $this->redis->executeCommand('hmset',$field);
    }


    /**
     * Returns a value indicating whether there is any validation error.
     * @param string|null $attribute attribute name. Use null to check all attributes.
     * @return bool whether there is any error.
     */
    public function hasErrors($attribute = null)
    {
        return $attribute === null ? !empty($this->_errors) : isset($this->_errors[$attribute]);
    }

    /**
     * Returns the errors for all attributes or a single attribute.
     * @param string $attribute attribute name. Use null to retrieve errors for all attributes.
     * @property array An array of errors for all attributes. Empty array is returned if no error.
     * The result is a two-dimensional array. See [[getErrors()]] for detailed description.
     * @return array errors for all attributes or the specified attribute. Empty array is returned if no error.
     * Note that when returning errors for all attributes, the result is a two-dimensional array, like the following:
     *
     * ```php
     * [
     *     'username' => [
     *         'Username is required.',
     *         'Username must contain only word characters.',
     *     ],
     *     'email' => [
     *         'Email address is invalid.',
     *     ]
     * ]
     * ```
     *
     * @see getFirstErrors()
     * @see getFirstError()
     */
    public function getErrors($attribute = null)
    {
        if ($attribute === null) {
            return $this->_errors === null ? [] : $this->_errors;
        }
        return isset($this->_errors[$attribute]) ? $this->_errors[$attribute] : [];
    }

    /**
     * Returns the first error of every attribute in the model.
     * @return array the first errors. The array keys are the attribute names, and the array
     * values are the corresponding error messages. An empty array will be returned if there is no error.
     * @see getErrors()
     * @see getFirstError()
     */
    public function getFirstErrors()
    {
        if (empty($this->_errors)) {
            return [];
        }

        $errors = [];
        foreach ($this->_errors as $name => $es) {
            if (!empty($es)) {
                $errors[$name] = reset($es);
            }
        }
        return $errors;
    }

    /**
     * Returns the first error of the specified attribute.
     * @param string $attribute attribute name.
     * @return string the error message. Null is returned if no error.
     * @see getErrors()
     * @see getFirstErrors()
     */
    public function getFirstError($attribute)
    {
        return isset($this->_errors[$attribute]) ? reset($this->_errors[$attribute]) : null;
    }

    /**
     * Adds a new error to the specified attribute.
     * @param string $attribute attribute name
     * @param string $error new error message
     */
    public function addError($attribute, $error = '')
    {
        $this->_errors[$attribute][] = $error;
    }

    /**
     * Adds a list of errors.
     * @param array $items a list of errors. The array keys must be attribute names.
     * The array values should be error messages. If an attribute has multiple errors,
     * these errors must be given in terms of an array.
     * You may use the result of [[getErrors()]] as the value for this parameter.
     * @since 2.0.2
     */
    public function addErrors(array $items)
    {
        foreach ($items as $attribute => $errors) {
            if (is_array($errors)) {
                foreach ($errors as $error) {
                    $this->addError($attribute, $error);
                }
            } else {
                $this->addError($attribute, $errors);
            }
        }
    }

    /**
     * Removes errors for all attributes or a single attribute.
     * @param string $attribute attribute name. Use null to remove errors for all attributes.
     */
    public function clearErrors($attribute = null)
    {
        if ($attribute === null) {
            $this->_errors = [];
        } else {
            unset($this->_errors[$attribute]);
        }
    }

}